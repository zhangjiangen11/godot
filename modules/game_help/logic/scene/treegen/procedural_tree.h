
/**
 * Procedural tree generated by parametric method.
 *
 * Reference:
 * [1] Weber, J., & Penn, J. (1995, September). Creation and rendering of
 *     realistic trees. In Proceedings of the 22nd annual conference on Computer
 *     graphics and interactive techniques (pp. 119-128).
 * [2] Hewitt, C. (2017). Procedural generation of tree models for use in
 *     computer graphics [Ph. D. dissertation]: Cambridge. University of
 *     Cambridge.
 */
//
// Copyright 2022 Yangbin Lin. All Rights Reserved.
//
// Author: yblin@jmu.edu.cn (Yangbin Lin)
//
// This file is part of the Code Library.
//

#pragma once

#include "core/math/color.h"
#include "core/math/plane.h"
#include "core/math/quaternion.h"
#include "core/math/transform_3d.h"
#include "core/math/vector2.h"
#include "core/math/vector3.h"
#include "core/variant/typed_array.h"
#include "scene/3d/node_3d.h"
#include "scene/main/node.h"
#include <algorithm>
#include <random>

#include "leaf_generator.h"

struct ProceduralTreePipe : public ProceduralTreeRenderData {
	ProceduralTreePipe() {}

	ProceduralTreePipe(const LocalVector<Vector3> &points, float radius, uint32_t p_slices = 32) :
			points_(points) {
		radius_.assign(points.size(), radius);
		////CHECK(radius > 0.0f);

		Initialize(n_slices);
	}

	/**
	 * Construct pipe with different radius at each vertex.
	 */
	ProceduralTreePipe(const LocalVector<Vector3> &points, const LocalVector<float> &radius,
			uint32_t p_slices = 32) :
			points_(points),
			radius_(radius) {
		////CHECK(points.size() == radius.size());

		Initialize(p_slices);
	}

	/**
	 * Construct a cylinder.
	 */
	ProceduralTreePipe(const Vector3 &p1, const Vector3 &p2, float radius,
			uint32_t p_slices = 32) :
			points_({ p1, p2 }) {
		radius_.assign(2, radius);
		////CHECK(radius > 0.0f);

		Initialize(p_slices);
	}

private:
	void Initialize(int p_slices) {
		////CHECK(points_.size() == radius_.size());
		////CHECK(n_slices >= 3);
		n_slices = p_slices;
		if (points_.size() <= 1) {
			return;
		}

		LocalVector<Vector3> ps;
		float angle = 2.0f * float(Math::PI) / n_slices;
		float r = 0.0f;
		for (uint32_t i = 0; i < n_slices; ++i, r += angle) {
			ps.emplace_back(std::cos(r), std::sin(r), 0.0f);
		}
		ps.push_back(ps.front());

		const float threshold = std::sqrt(FLT_EPSILON);
		Vector3 v = points_[1] - points_[0];

		Transform3D transform;
		transform.basis.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), Vector3(v.x, v.y, v.z));
		transform.origin = points_[0];
		for (Vector3 &p : ps) {
			p = transform.xform(p);
		}
		float norm = 0;
		// Set vertices and normals.
		for (uint32_t j = 0; j < points_.size(); ++j) {
			if (j > 0) {
				const Vector3 &p0 = points_[j - 1];
				const Vector3 &p1 = points_[j];

				Vector3 v1 = p0 - p1;
				norm = v1.length();
				if (norm <= FLT_EPSILON) {
					continue;
				}
				v1 *= 1.0f / norm;
				Vector3 tv = v1;

				if (j + 1 < points_.size()) {
					const Vector3 &p2 = points_[j + 1];
					Vector3 v2 = p2 - p1;
					norm = v2.length();
					if (norm > FLT_EPSILON) {
						v2 *= 1.0f / norm;

						Vector3 v3 = v1.cross(v2);
						Vector3 v4 = v1 + v2;
						tv = v3.cross(v4);
						if (v3.length() < threshold || v4.length() < threshold ||
								tv.length() < threshold) {
							tv = v1;
						}
					}
				}
				Plane plane(Vector3(v.x, v.y, v.z), Vector3(p1.x, p1.y, p1.z));
				for (uint32_t i = 0; i < ps.size(); ++i) {
					//FLine3D line(ps[i], Vector3(v1.x, v1.y, v1.z));
					//geometry::Cross(line, plane, &ps[i]);
					plane.intersects_segment(ps[i], v1, &ps[i]);
				}
			}

			for (uint32_t i = 0; i < ps.size(); ++i) {
				vertices.push_back(points_[j] + (ps[i] - points_[j]) * radius_[j]);

				uint32_t next = i + 1 == ps.size() ? 1 : i + 1;
				int prev = i == 0 ? ps.size() - 2 : i - 1;
				Vector3 v1 = ps[prev] - ps[i];
				Vector3 v2 = ps[next] - ps[i];
				Vector3 tv = -(v1 + v2);
				normals.push_back(tv.normalized());
			}

			if (j > 0 && j + 1 < points_.size()) {
				int offset = vertices.size() - ps.size();
				vertices.insert(vertices.begin() + offset,
						vertices.begin() + (offset + ps.size()));
				normals.insert(normals.begin() + offset,
						normals.begin() + (offset + ps.size()));
			}
		}

		// Set texture coordinates.
		for (uint32_t j = 0; j < points_.size(); ++j) {
			if (j == 0) {
				for (uint32_t i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 0.0f);
				}
			} else if (j + 1 == points_.size()) {
				for (uint32_t i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 1.0f);
				}
			} else {
				for (uint32_t i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 1.0f);
				}
				for (uint32_t i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 0.0f);
				}
			}

			if (j > 0) {
				int offset = 2 * ps.size() * (j - 1);
				for (uint32_t i = 0; i < n_slices; ++i) {
					uint32_t next = i + 1;
					indices.push_back(offset + i);
					indices.push_back(offset + next);
					indices.push_back(offset + i + ps.size());

					indices.push_back(offset + i + ps.size());
					indices.push_back(offset + next);
					indices.push_back(offset + next + ps.size());
				}
			}
		}
	}

	// Vertices of the pipe.
	LocalVector<Vector3> points_;

	// Radius of each vertex of the pipe.
	LocalVector<float> radius_;

	// Number of slices of each circle.
	uint32_t n_slices = 0;
};

/**
 * 树的枝干。
 */
struct ProceduralTreeStem {
	// 此枝干的深度。
	int depth = 0;

	// 枝干的基础半径。
	float radius = 0.0f;

	// 最大半径。
	float radius_limit = 0.0f;

	// 枝干的长度。
	float length = 0.0f;

	// 此枝干的最大长度。
	float max_length = 0.0f;

	// 父枝干的长度。
	float parent_length = 0.0f;

	// 总长度
	float total_length = 0.0f;

	// 此枝干在父树干中的位置偏移量。
	float offset = 0.0f;

	// 用于生成分支和树叶的旋转角度。
	float prev_rotation_angle = 0.0f;

	// 此枝干的单位生长方向。
	Vector3 orientation;

	// 此枝干的单位朝向。
	Vector3 face_orientation;

	// 此枝干的根位置。
	Vector3 root;

	// 此枝干的树干部分。
	ProceduralTreePipe trunk;

	// 一个枝干可能有多个子枝干。
	LocalVector<ProceduralTreeStem> sub_stems;

	// 此枝干的分支。
	LocalVector<ProceduralTreeStem> branches;

	/**
	 * 围绕生长方向旋转此枝干。
	 */
	void Roll(float degree) {
		Basis rot(orientation, Math::deg_to_rad(degree));
		face_orientation = rot.xform(face_orientation);
	}

	/**
	 * 围绕Z轴旋转此枝干。
	 */
	void GlobalRoll(float degree) {
		Basis rot(Vector3(0.0f, 0.0f, 1.0f),
				Math::deg_to_rad(degree));
		orientation = rot.xform(orientation);
		face_orientation = rot.xform(face_orientation);
	}

	/**
	 * 围绕垂直于生长方向和朝向的轴俯仰此枝干。
	 */
	void Pitch(float degree) {
		Vector3 v = orientation.cross(face_orientation);
		Basis rot(v, Math::deg_to_rad(degree));
		orientation = rot.xform(orientation);
		face_orientation = rot.xform(face_orientation);
	}
};

class ProceduralTree : public Node3D {
	GDCLASS(ProceduralTree, Node3D);
	static void _bind_methods();

public:
	/**
	 * 用于表示分支模式的枚举。
	 */
	enum BranchMode {
		ALTERNATE_OR_OPPOSITE = 1, // 互生或对生
		WHORLED = 2, // 轮生
		FAN = 3 // 扇形
	};

	/**
	 * 叶子/花朵信息。
	 */
	struct LeafBlossom {
		Vector3 orientation; // 朝向
		Vector3 face_orientation; // 正面朝向
		Vector3 position; // 位置
		float length = 0.0f; // 长度
	};

public:
	explicit ProceduralTree(const std::string &name = "", int seed = 0) :
			uniform_random1_(-1.0f, 1.0f),
			uniform_random2_(0.0f, 1.0f),
			random_engine_(seed) {
		//leaf_material_.ao = 1.0f;
		//leaf_material_.albedo = leaf_color_;
		//leaf_material_.metallic = 0.2f;
		//leaf_material_.roughness = 0.8f;
		//leaves_node_.set_material(&leaf_material_);
		//this->AddNode(&leaves_node_);

		//this->AddRenderObject(&stem_object_);
	}

	/**
	 * 根据给定的参数重新生成树模型。
	 */
	void Generate(const Ref<ProceduralTreeParameter> &parameter) {
		if (parameter.is_null()) {
			return;
		}
		parameter_ = parameter;

		n_branches_ = 0;
		n_branch_segments_ = 0;
		CreateTree();
		GenerateLeaves();
	}

	/**
	 * 设置枝干的LOD（细节层次）用于渲染。
	 */
	void SetStemsLOD(int level) {
		stems_lod_ = level;
	}

	/**
	 * 设置叶子颜色。
	 */
	void set_leaf_color(const Color &color) {
		leaf_color_ = color;
	}
	/**
	 * 为随机引擎设置种子。
	 */
	void set_seed(int p_seed) {
		seed = p_seed;
		random_engine_.seed(p_seed);
	}
	int get_seed() const {
		return seed;
	}

	/**
	 * 返回树的总分支数量。
	 */
	int n_branches() const {
		return n_branches_;
	}
	/**
	 * 返回树的总分支段数量。
	 */
	int get_branch_segments() const {
		return n_branch_segments_;
	}

	/**
	 * 返回叶子的总数量。
	 */
	int n_leaves() const {
		return leaves_.size();
	}

	/**
	 * 返回枝干的LOD（细节层次）。
	 */
	int stems_lod() const {
		return stems_lod_;
	}

private:
	/**
	 * 递归添加枝干。
	 */
	void AddStems(const ProceduralTreeStem &stem) {
		if (stem.depth >= stems_lod_) {
			return;
		}

		//stem_object_.Add(stem.trunk);
		for (const ProceduralTreeStem &_stem : stem.sub_stems) {
			AddStems(_stem);
		}
		for (const ProceduralTreeStem &_stem : stem.branches) {
			AddStems(_stem);
		}
	}

	/**
	 * 创建树。
	 */
	void CreateTree() {
		leaves_generated_ = false;
		tree_.clear();
		leaves_.clear();

		if (parameter_->branches[0] == 0) {
			return;
		}

		std::uniform_real_distribution<float> uniform(0.0f, float(Math::PI) * 2.0f);

		// 计算枝干起始点的泊松分布点。
		LocalVector<Vector3> roots;
		if (parameter_->branches[0] == 1) {
			roots.push_back(Vector3(0.0f, 0.0f, 0.0f));
		} else {
			// 计算虚拟枝干的近似间距半径。
			tree_scale_ = parameter_->scale + parameter_->scale_v;

			ProceduralTreeStem temp_stem;
			temp_stem.length = StemLength(temp_stem);
			float radius = 2.5f * temp_stem.length * parameter_->ratio *
					parameter_->radius_modify[0];

			// 生成根点。
			for (int i = 0; i < parameter_->branches[0]; ++i) {
				bool point_ok = false;
				while (!point_ok) {
					// 与中心的距离与分割数量、树的比例和枝干半径成比例。
					float dis = std::sqrt(GetRandomNumber2() *
							parameter_->branches[0] / 2.5f *
							parameter_->scale *
							parameter_->ratio);

					// 圆内的随机角度。
					float theta = uniform(random_engine_);
					Vector3 pos(dis * std::cos(theta), dis * std::sin(theta),
							0.0f);

					// 测试该点与已在数组中的点，确保它们不会相交。
					bool flag = true;
					for (const Vector3 &p : roots) {
						if (p.distance_to(pos) < radius) {
							flag = false;
							break;
						}
					}
					if (flag) {
						point_ok = true;
						roots.push_back(pos);
					}
				}
			}
		}

		for (const Vector3 &root : roots) {
			tree_scale_ = GetRandom(parameter_->scale, parameter_->scale_v);

			ProceduralTreeStem stem;
			stem.length = StemLength(stem);
			stem.parent_length = stem.length;
			stem.max_length = GetMaxLength(0);
			stem.radius = stem.length * parameter_->ratio *
					parameter_->radius_modify[0];
			stem.radius_limit = FLT_MAX;
			stem.orientation = Vector3(0.0f, 0.0f, 1.0f);
			stem.root = root;
			if (roots.size() > 1) {
				stem.face_orientation = root.normalized();
				float angle = GetRandomNumber1() * 30.0f;
				stem.Roll(angle);
			} else {
				float angle = uniform(random_engine_);
				stem.face_orientation = Vector3(std::cos(angle),
						std::sin(angle),
						0.0f);
			}

			split_num_error_.assign(parameter_->levels, 0.0f);
			MakeStem(0, 1.0f, 1.0f, &stem);
			tree_.push_back(stem);
		}
	}

	/**
	 * 生成叶子和花朵。
	 */
	void GenerateLeaves() {
		if (leaves_generated_) {
			return;
		}
		leaves_generated_ = true;

		SetupLeafNode();

		float bend = parameter_->leaf_bend;
		Transform3D leaf_transform;
		Transform3D transform2;
		Vector3 v;
		for (const LeafBlossom &l : leaves_) {
			Transform3D transform;
			transform.origin = Vector3(l.position);
			Basis q;
			q.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), l.orientation);
			v = q.xform(Vector3(0.0f, 1.0f, 0.0f));
			Basis q1;
			q1.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), l.face_orientation);
			Transform3D transform1;
			transform1.basis = q1 * q;
			if (bend > 0.0f) {
				float theta_pos = std::atan2(l.position.y, l.position.x);
				float theta_bend = theta_pos - std::atan2(l.face_orientation.y, l.face_orientation.x);
				//FQuaternion q2(Vector3(0.0f, 0.0f, 1.0f), theta_bend * bend);
				Basis q2;
				q2.rotate(Vector3(0.0f, 0.0f, 1.0f), theta_bend * bend);
				transform2.basis = (q2);
				leaf_transform = (transform * transform2 * transform1);
			} else {
				leaf_transform = (transform * transform1);
			}
			if (parameter_->blossom_rate > 0.0f && parameter_->blossom_scale > 0.0f && GetRandomNumber2() < parameter_->blossom_rate) {
				blossom_node_.AddInstance(leaf_transform, l.length);
			} else {
				leaves_node_.AddInstance(leaf_transform, l.length);
			}
		}
	}

	/**
	 * 设置实例化叶子节点。
	 */
	void SetupLeafNode() {
		LeafGenerator leaf_generator;
		ProceduralTreeRenderData leaf_render_data;
		ProceduralTreeRenderData blossom_render_data;
		switch (parameter_->leaf_shape) {
			case 1:
				leaf_generator.OctaveLeaf(&leaf_render_data); // 八度叶
				break;
			case 2:
				leaf_generator.LinearLeaf(&leaf_render_data); // 线性叶
				break;
			case 3:
				leaf_generator.CordateLeaf(&leaf_render_data); // 心形叶
				break;
			case 4:
				leaf_generator.MapleLeaf(&leaf_render_data); // 枫叶
				break;
			case 5:
				leaf_generator.PalmateLeaf(&leaf_render_data); // 掌状叶
				break;
			case 6:
				leaf_generator.SpikyOakLeaf(&leaf_render_data); // 尖橡叶
				break;
			case 7:
				leaf_generator.RoundOakLeaf(&leaf_render_data); // 圆橡叶
				break;
			case 8:
				leaf_generator.EllipticLeaf(&leaf_render_data); // 椭圆形叶
				break;
			case 9:
				leaf_generator.RectLeaf(&leaf_render_data); // 矩形叶
				break;
			case 10:
				leaf_generator.TriangleLeaf(&leaf_render_data); // 三角形叶
				break;
		}
		switch (parameter_->blossom_shape) {
			case 1:
				leaf_generator.CherryLeaf(&blossom_render_data); // 樱花叶
				break;
			case 2:
				leaf_generator.OrangeLeaf(&blossom_render_data); // 橙花叶
				break;
			case 3:
				leaf_generator.MagnoliaLeaf(&blossom_render_data); // 木兰叶
				break;
		}

		float scale = parameter_->leaf_scale * tree_scale_ / parameter_->scale;
		float scale_x = parameter_->leaf_scale_x;
		for (Vector3 &p : leaf_render_data.vertices) {
			p *= scale;
			p.x *= scale_x;
		}
		scale = parameter_->blossom_scale * tree_scale_ / parameter_->scale;
		for (Vector3 &p : blossom_render_data.vertices) {
			p *= scale;
		}
		leaves_node_.Reset(leaf_render_data);
		blossom_node_.Reset(blossom_render_data);
	}

	/**
	 * 为当前枝干段创建新的分支。
	 */
	void CreateBranch(BranchMode branch_mode,
			const Vector3 &start_point,
			const Vector3 &end_point,
			float offset,
			float stem_offset,
			int branch_index,
			int branches_in_group,
			bool is_leaf,
			ProceduralTreeStem *stem) {
		int depth_1 = NextDepth(stem->depth);

		float angle = 0.0f;
		float radius_limit = 0.0f;
		Transform3D transform;
		Vector3 p_euler;
		switch (branch_mode) {
			case FAN:
				if (branches_in_group == 1) {
					angle = 0.0f;
				} else {
					angle = (parameter_->rotation[depth_1] *
									((branch_index / (branches_in_group - 1.0f)) - 0.5f)) +
							GetRandomNumber1() * parameter_->rotation_v[depth_1];
				}
				p_euler.y = (angle);
				radius_limit = 0.0f;
				break;
			case WHORLED:
				angle = stem->prev_rotation_angle +
						(360.0f * branch_index / branches_in_group) +
						GetRandomNumber1() * parameter_->rotation_v[depth_1];
				p_euler.z = (angle);
				radius_limit = CalculateRadius(*stem, stem_offset / stem->length);

				break;
			case ALTERNATE_OR_OPPOSITE:
				angle = GetRotateAngle(depth_1, stem->prev_rotation_angle);
				if (parameter_->rotation[depth_1] >= 0.0f) {
					stem->prev_rotation_angle = angle;
				} else {
					stem->prev_rotation_angle = -stem->prev_rotation_angle;
				}
				p_euler.z = (angle);
				radius_limit = CalculateRadius(*stem, stem_offset / stem->length);
				break;
		}

		// 计算下偏角度。
		float d_angle = GetDownAngle(*stem, stem_offset);
		p_euler.x = (d_angle);
		transform.basis = Basis::from_euler(p_euler);

		ProceduralTreeStem branch;
		branch.depth = depth_1;
		branch.parent_length = stem->length;
		branch.offset = stem_offset;
		branch.max_length = GetMaxLength(depth_1);
		branch.length = StemLength(branch);
		// 计算整体长度
		branch.total_length = stem->total_length + branch.length;
		branch.radius_limit = radius_limit;
		branch.radius = parameter_->radius_modify[depth_1] *
				stem->radius *
				std::pow(branch.length / branch.parent_length,
						parameter_->ratio_power);
		branch.radius = CLAMP(branch.radius, 0.005f, radius_limit);
		branch.orientation = transform.xform(stem->orientation);
		branch.face_orientation = transform.xform(stem->face_orientation);
		branch.root = start_point + (end_point - start_point) * offset +
				radius_limit * branch.orientation;

		if (is_leaf) {
			LeafBlossom leaf;
			leaf.position = branch.root;
			leaf.orientation = branch.orientation;
			leaf.face_orientation = branch.face_orientation;
			leaf.length = branch.total_length;
			if (leaf.face_orientation.z < 0.0f) {
				leaf.face_orientation = -leaf.face_orientation;
			}
			leaf.face_orientation.normalize();
			leaves_.push_back(leaf);
		} else {
			MakeStem(0, 1.0f, 1.0f, &branch);
			stem->branches.push_back(branch);
		}
	}

	/**
	 * 根据给定的参数生成枝干，以及所有子元素（分支、分叉和叶子），通过递归实现。
	 */
	void MakeStem(int start,
			float clone_probability,
			float n_branches_factor,
			ProceduralTreeStem *stem) {
		if (start >= parameter_->curve_resolution[stem->depth]) {
			return;
		}

		// 如果枝干细到看不见，就不必生成它了。
		if (stem->radius_limit < 0.0001f) {
			return;
		}

		// 参数。
		int depth = stem->depth;
		int curve_res = parameter_->curve_resolution[depth];
		float taper = parameter_->taper[depth];
		int base_segment_index =
				static_cast<int>(std::ceil(parameter_->base_size[0] *
						curve_res));
		int base_splits = parameter_->base_splits;
		float seg_splits = parameter_->segment_splits[depth];
		float seg_length = stem->length / curve_res;

		LocalVector<Vector3> vertices;
		LocalVector<float> radius;

		// 起始点。
		Vector3 start_point = stem->root;

		vertices.emplace_back(start_point);
		radius.push_back(CalculateRadius(*stem, float(start) / curve_res));

		float branch_count = 0.0f;
		float leaf_count = 0.0f;
		if (depth == parameter_->levels - 1 && depth > 0 &&
				parameter_->n_leaves != 0) {
			// 计算基础叶子数量。
			leaf_count = CalculateLeafCount(*stem);
			// 根据沿枝干的起始位置校正叶子数量。
			leaf_count *= 1.0f - float(start) / curve_res;
		} else {
			// 计算基础分支数量。
			branch_count = CalculateBranchCount(*stem);
			// 根据沿枝干的起始位置校正分支数量。
			branch_count *= 1.0f - float(start) / curve_res;
			// 根据克隆分支的数量减少进行校正。
			branch_count *= n_branches_factor;
		}

		// 除以曲线分辨率得到每段的数量。
		float f_leaves_on_segment = leaf_count / curve_res;
		// 除以曲线分辨率得到每段的数量。
		float f_branches_on_segment = branch_count / curve_res;

		// 确定分支/叶子的起始旋转角度。
		stem->prev_rotation_angle = 0.0f;
		std::uniform_real_distribution<float> uniform(0.0f, 360.0f);
		if (parameter_->rotation[NextDepth(depth)] >= 0.0f) {
			// 从随机旋转角度开始。
			stem->prev_rotation_angle = uniform(random_engine_);
		} else {
			// 在这种情况下，prev_rotation_angle用作乘数来交替分支的侧面。
			stem->prev_rotation_angle = 1.0f;
		}

		// 此段的点分辨率。
		int points_per_segment = 2;
		if (depth == 0 || taper > 1.0f) {
			points_per_segment = std::max(2, 100 / curve_res);
		}

		// 设置Floyd-Steinberg误差值。
		float branch_num_error = 0.0f;
		float leaf_num_error = 0.0f;

		for (int i = start; i < curve_res; ++i) {
			bool is_base_split = false;
			// 计算此段的分叉数量。
			int n_splits = 0;
			if (i != start) {
				if (base_splits > 0 && depth == 0 && i == base_segment_index) {
					n_splits = base_splits;
					is_base_split = true;
				} else if (seg_splits > 0.0f && i + 1 < curve_res &&
						(depth > 0 || i > base_segment_index)) {
					// 否则从seg_splits获取分叉数量，并使用Floyd-Steinberg来修正非整数值，仅以clone_prob的概率克隆。
					if (GetRandomNumber2() <= clone_probability) {
						n_splits = static_cast<int>(seg_splits +
								split_num_error_[depth]);
						split_num_error_[depth] -= n_splits - seg_splits;

						// 降低克隆/分支倾向。
						clone_probability /= n_splits + 1.0f;
						n_branches_factor /= n_splits + 1.0f;
						n_branches_factor = std::max(0.8f, n_branches_factor);

						branch_count *= n_branches_factor;
						f_branches_on_segment = branch_count / curve_res;
					}
				}
			}

			// 必要时进行分叉。
			float split_corr_angle = 0.0f;
			if (n_splits > 0) {
				float declination = Math::rad_to_deg(stem->orientation.angle_to(
						Vector3(0.0f, 0.0f, 1.0f)));
				float spl_angle = GetSplitAngle(depth, declination);
				float spr_angle = GetSpreadAngle(declination);
				split_corr_angle = spl_angle / (curve_res - i);

				// 制作克隆。
				for (int j = 0; j < n_splits; ++j) {
					float eff_spr_angle = 0.0f;
					if (is_base_split) {
						eff_spr_angle = GetEffectSpreadAngle(depth, j,
								n_splits);
					} else {
						if (j == 0) {
							eff_spr_angle = spr_angle * 0.5f;
						} else {
							eff_spr_angle = -spr_angle * 0.5f;
						}
					}

					ProceduralTreeStem sub_stem = *stem;
					sub_stem.branches.clear();
					sub_stem.sub_stems.clear();
					sub_stem.root = start_point;
					sub_stem.GlobalRoll(eff_spr_angle);
					sub_stem.Pitch(spl_angle * 0.5f);

					MakeStem(i, clone_probability, n_branches_factor,
							&sub_stem);
					stem->sub_stems.push_back(sub_stem);
				}

				stem->Pitch(spl_angle * 0.5f);
				// 如果分叉为2且不是基础分叉，则应用展开。
				if (!is_base_split && n_splits == 1) {
					stem->GlobalRoll(-spr_angle * 0.5f);
				}
			}

			float radian = CalculateCurveAngle(depth, i);
			stem->Roll(GetBendv(depth));
			stem->Pitch(radian - split_corr_angle);

			// 如果不是树干/主分支则应用完全向性，如果是则应用水平向性。
			if (i > start) {
				ApplyTropism(stem);
			}

			Vector3 v = stem->orientation;
			for (int j = 1; j < points_per_segment; ++j) {
				float offset = float(j) / (points_per_segment - 1);
				float z_norm = (i + offset) / curve_res;
				float r = CalculateRadius(*stem, z_norm);
				radius.push_back(r);
				vertices.emplace_back(start_point + v * offset * seg_length);
			}

			// 为此段添加分支/叶子。
			// 如果低于递归的最大级别，则绘制分支，否则绘制叶子。
			int branches_on_segment = 0;
			int leaves_on_segment = 0;
			if (branch_count != 0.0f && depth < parameter_->levels - 1) {
				if (branch_count < 0.0f) {
					// 扇形分支。
					if (i + 1 == curve_res) {
						branches_on_segment = static_cast<int>(branch_count);
					} else {
						branches_on_segment = 0;
					}
				} else {
					// 获取Floyd-Steinberg校正的分支数量。
					branches_on_segment =
							static_cast<int>(f_branches_on_segment +
									branch_num_error);
					branch_num_error -= branches_on_segment -
							f_branches_on_segment;
				}

				// 添加分支。
				if (branches_on_segment != 0) {
					MakeBranches(i, start_point, start_point + v * seg_length,
							branches_on_segment, false, stem);
				}
			} else if (leaf_count != 0.0f && depth > 0) {
				if (leaf_count < 0.0f) {
					// 扇形叶子。
					if (i + 1 == curve_res) {
						leaves_on_segment = static_cast<int>(leaf_count);
					} else {
						leaves_on_segment = 0;
					}
				} else {
					// 获取Floyd-Steinberg校正的分支数量。
					leaves_on_segment = static_cast<int>(f_leaves_on_segment +
							leaf_num_error);
					leaf_num_error -= leaves_on_segment - f_leaves_on_segment;
				}

				// 添加叶子。
				if (leaves_on_segment != 0) {
					MakeBranches(i, start_point, start_point + v * seg_length,
							leaves_on_segment, true, stem);
				}
			}

			start_point += v * seg_length;
			++n_branch_segments_;
		}

		if (depth == 0) {
			stem->trunk = ProceduralTreePipe(vertices, radius, 16);
		} else if (depth == 1) {
			stem->trunk = ProceduralTreePipe(vertices, radius, 8);
		} else {
			stem->trunk = ProceduralTreePipe(vertices, radius, 4);
		}

		++n_branches_;
	}

	/**
	 * 为枝干的第i段生成所需的分支。
	 */
	void MakeBranches(int segment_index,
			const Vector3 &start_point,
			const Vector3 &end_point,
			int branches_on_segment,
			bool is_leaf,
			ProceduralTreeStem *stem) {
		//CHECK(stem);

		float offset = 1.0f;
		float stem_offset = 1.0f;
		if (branches_on_segment < 0) {
			// 扇形分支。
			for (int i = 0; i < std::abs(branches_on_segment); ++i) {
				CreateBranch(FAN, start_point, end_point, offset, stem_offset,
						i, std::abs(branches_on_segment), is_leaf, stem);
			}
			return;
		}

		int depth_1 = NextDepth(stem->depth);
		float base_length = stem->length * parameter_->base_size[stem->depth];
		float branch_dist = parameter_->branch_dist[depth_1];
		int curve_res = parameter_->curve_resolution[stem->depth];

		if (branch_dist > 1.0f) {
			// 轮生分支。
			// 计算轮生数量，将导致分支数量为整数，而不是branches_on_segment指定的确切数量。
			int num_of_whorls = static_cast<int>(branches_on_segment /
					(branch_dist + 1.0f));
			float branches_per_whorl = branch_dist + 1.0f;
			float branch_whorl_error = 0.0f;

			for (int i = 0; i < num_of_whorls; ++i) {
				// 计算段内和枝干上的轮生偏移量。
				offset = CLAMP(float(i) / num_of_whorls, 0.0f, 1.0f);
				stem_offset = ((segment_index + offset) / curve_res) *
						stem->length;

				// 如果不在基础区域，则生成分支。
				if (stem_offset > base_length) {
					// 计算此轮生的Floyd-Steinberg校正的分支数量。
					int branches_this_whorl =
							static_cast<int>(branches_per_whorl +
									branch_whorl_error);
					branch_whorl_error -= branches_this_whorl -
							branches_per_whorl;

					// 设置这些分支。
					for (int j = 0; j < branches_this_whorl; ++j) {
						CreateBranch(WHORLED, start_point, end_point, offset,
								stem_offset, j, branches_this_whorl,
								is_leaf, stem);
					}
				}

				// 为下一轮生旋转起始角度。
				stem->prev_rotation_angle += parameter_->rotation[depth_1];
			}
		} else {
			// 互生或对生分支。
			// 如果接近对生，则确保段上的分支数量为偶数。
			for (int i = 0; i < branches_on_segment; ++i) {
				// 计算段内和枝干上的偏移量。
				if (i % 2 == 0) {
					offset = CLAMP(float(i) / branches_on_segment, 0.0f, 1.0f);
				} else {
					offset = CLAMP((i - branch_dist) / branches_on_segment,
							0.0f, 1.0f);
				}

				stem_offset = ((segment_index + offset) / curve_res) *
						stem->length;

				// 如果不在基础区域，则设置分支。
				if (stem_offset > base_length) {
					CreateBranch(ALTERNATE_OR_OPPOSITE, start_point,
							end_point, offset, stem_offset, i, 1, is_leaf,
							stem);
				}
			}
		}
	}

	/**
	 * 计算枝干上沿偏移量z_1处的半径。
	 *
	 * 更多细节参见参考文献[1]。
	 */
	float CalculateRadius(const ProceduralTreeStem &stem, float z_norm) const {
		float n_taper = parameter_->taper[stem.depth];

		float unit_taper = 0.0f;
		if (n_taper < 1.0f) {
			unit_taper = n_taper;
		} else if (n_taper < 2.0f) {
			unit_taper = 2.0f - n_taper;
		}

		// 纯锥形半径。
		float taper = stem.radius * (1.0f - unit_taper * z_norm);

		float radius;
		if (n_taper < 1.0f) {
			radius = taper;
		} else {
			float z2 = (1.0f - z_norm) * stem.length;

			// 'depth'是用于周期性锥形的缩放因子。
			float depth;
			if (n_taper < 2.0f || z2 < taper) {
				depth = 1.0f;
			} else {
				depth = n_taper - 2.0f;
			}

			float z3;
			if (n_taper < 2.0f) {
				z3 = z2;
			} else {
				z3 = std::abs(z2 - 2.0f * taper * std::round(z2 / (2.0f * taper)));
			}
			if (n_taper < 2.0f && z3 >= taper) {
				radius = taper;
			} else {
				radius = (1.0f - depth) * taper +
						depth * std::sqrt(std::pow(taper, 2.0f) - std::pow((z3 - taper), 2.0f));
			}
		}

		if (stem.depth == 0) {
			float y_val = std::max(0.0f, 1.0f - 8.0f * z_norm);
			float flare = parameter_->flare *
							((std::pow(100.0f, y_val) - 1.0f) / 100.0f) +
					1.0f;
			radius *= flare;
		}
		return radius;
	}

	/**
	 * 计算给定枝干的长度。
	 */
	float StemLength(const ProceduralTreeStem &stem) const {
		static float base_length = 0.0f;

		float result = 0.0f;
		if (stem.depth == 0) {
			base_length = stem.length * parameter_->base_size[0];
			result = tree_scale_ * GetMaxLength(0);
		} else if (stem.depth == 1) {
			result = stem.parent_length * stem.max_length *
					ShapeRatio(parameter_->shape,
							(stem.parent_length - stem.offset) /
									(stem.parent_length - base_length));

		} else {
			result = stem.max_length *
					(stem.parent_length - 0.7f * stem.offset);
		}

		return std::max(0.0f, result);
	}

	/**
	 * 按照参考文献[1]中的定义计算形状比例。
	 */
	float ShapeRatio(int shape, float ratio) const {
		switch (shape) {
			case 1: // 球形
				return 0.2f + 0.8f * std::sin(float(Math::PI) * ratio);
			case 2: // 半球形
				return 0.2f + 0.8f * std::sin(float(Math::PI * 2.0) * ratio);
			case 3: // 圆柱形
				return 1.0f;
			case 4: // 锥形圆柱
				return 0.5f + 0.5f * ratio;
			case 5: // 火焰形
				return ratio <= 0.7f ? ratio / 0.7f : (1.0f - ratio) / 0.3f;
			case 6: // 倒锥形
				return 1.0f - 0.8f * ratio;
			case 7: // 细长火焰形
				return ratio <= 0.7f ? 0.5f + 0.5f * ratio / 0.7f
									 : 0.5f + 0.5f * (1.0f - ratio) / 0.3f;
			case 8: // 信封形
				if (ratio < 0.0f || ratio > 1.0f) {
					return 0.0f;
				} else if (ratio < 1.0f - parameter_->prune_width_peak) {
					return std::pow(ratio / (1.0f - parameter_->prune_width_peak),
							parameter_->prune_power_high);
				} else {
					return std::pow((1.0f - ratio) /
									(1.0f - parameter_->prune_width_peak),
							parameter_->prune_power_low);
				}
			default: // 锥形 (0)
				return 0.2f + 0.8f * ratio;
		}
	}

	/**
	 * 对枝干应用向性。
	 */
	void ApplyTropism(ProceduralTreeStem *stem) {
		Vector3 v = Vector3(parameter_->tropism[0], parameter_->tropism[1],
				parameter_->tropism[2]);
		if (stem->depth <= 1) {
			v.z = 0.0f;
		}

		if (v.x != 0.0f || v.y != 0.0f || v.z != 0.0f) {
			Vector3 v2 = stem->orientation.cross(v);
			float alpha = v2.length() * 10.0f;

			Basis rot(v2, Math::deg_to_rad(alpha));
			stem->orientation = rot.xform(stem->orientation);
			stem->face_orientation = rot.xform(stem->face_orientation);
		}
	}

	/**
	 * 计算枝干上第index段的弯曲角度。
	 */
	float CalculateCurveAngle(int depth, int index) const {
		float curve = parameter_->curve[depth];
		float curve_back = parameter_->curve_back[depth];
		int curve_res = parameter_->curve_resolution[depth];
		float curve_v = parameter_->curve_v[depth];

		float curve_angle = 0.0f;
		if (curve_back == 0) {
			curve_angle = curve / curve_res;
		} else if (index < curve_res * 0.5f) {
			curve_angle = curve / (curve_res * 0.5f);
		} else {
			curve_angle = curve_back / (curve_res * 0.5f);
		}

		return GetRandom(curve_angle, curve_v / curve_res);
	}

	/**
	 * 计算此枝干的分支数量。
	 */
	float CalculateBranchCount(const ProceduralTreeStem &stem) const {
		int depth_1 = std::min(stem.depth + 1, 3);
		float result = 0.0f;

		if (stem.depth == 0) {
			result = parameter_->branches[depth_1] *
					(GetRandomNumber2() * 0.2f + 0.9f);
		} else if (parameter_->branches[depth_1] < 0) {
			result = static_cast<float>(parameter_->branches[depth_1]);
		} else if (stem.depth == 1) {
			result = parameter_->branches[depth_1] *
					(0.2f + 0.8f * (stem.length / stem.parent_length) / stem.max_length);
		} else {
			result = parameter_->branches[depth_1] *
					(1.0f - 0.5f * stem.offset / stem.parent_length);
		}

		return result / (1.0f - parameter_->base_size[stem.depth]);
	}

	/**
	 * 计算此枝干的叶子数量。
	 */
	float CalculateLeafCount(const ProceduralTreeStem &stem) const {
		if (parameter_->n_leaves >= 0) {
			// 缩放叶子数量以匹配全局比例和锥形。
			float n = parameter_->n_leaves * tree_scale_ / parameter_->scale;
			return n * (stem.length / (stem.max_length * stem.length));
		}

		return static_cast<float>(parameter_->n_leaves);
	}

	/**
	 * 获取旋转角度，限制在0-360度之间。
	 */
	float GetRotateAngle(int n, float prev_angle) const {
		float r_angle;
		if (parameter_->rotation[n] >= 0.0f) {
			r_angle = prev_angle + GetRandom(parameter_->rotation[n], parameter_->rotation_v[n]);
		} else {
			r_angle = prev_angle * (180.0f + GetRandom(parameter_->rotation[n], parameter_->rotation_v[n]));
		}
		r_angle = std::fmod(r_angle, 360.0f);
		if (r_angle < 0.0f) {
			r_angle += 360.0f;
		}
		return r_angle;
	}

	/**
	 * 获取分支或叶子的下偏角度。
	 */
	float GetDownAngle(const ProceduralTreeStem &stem, float stem_offset) const {
		int depth_1 = NextDepth(stem.depth);
		float d_angle = 0.0f;
		if (parameter_->down_angle_v[depth_1] >= 0.0f) {
			d_angle = GetRandom(parameter_->down_angle[depth_1],
					parameter_->down_angle_v[depth_1]);
		} else {
			float base_size = parameter_->base_size[stem.depth];
			float ratio = ShapeRatio(0, (stem.length - stem_offset) / (stem.length * (1.0f - base_size)));
			d_angle = parameter_->down_angle[depth_1] +
					parameter_->down_angle_v[depth_1] * (1.0f - 2.0f * ratio);
		}

		// 引入一些变化以改善视觉效果。
		return GetRandom(d_angle, std::abs(d_angle * 0.1f));
	}

	/**
	 * 获取第n级分支的最大长度。
	 */
	float GetMaxLength(int n) const {
		return GetRandom(parameter_->length[n], parameter_->length_v[n]);
	}

	/**
	 * 获取分叉角度。
	 */
	float GetSplitAngle(int n, float declination) const {
		//CHECK(n >= 0 && n < parameter_->levels);

		float angle = GetRandom(std::abs(parameter_->split_angle[n]),
				parameter_->split_angle_v[n]);
		return std::max(0.0f, angle - declination);
	}

	/**
	 * 获取分叉后枝干的展开角度。
	 */
	float GetSpreadAngle(float declination) const {
		return -(20.0f + 0.75f * (30.0f + std::abs(declination - 90.0f)) * std::pow(GetRandomNumber2(), 2.0f));
	}

	/**
	 * 获取第i个克隆的展开角度。
	 */
	float GetEffectSpreadAngle(int depth, int i, int n_splits) const {
		//CHECK(i >= 0 && i < n_splits);
		//CHECK(depth >= 0 && depth < parameter_->levels);

		return (i + 1) * 360.0f / (n_splits + 1) + GetRandomNumber1() * parameter_->split_angle_v[depth];
	}

	/**
	 * 获取枝干方向从起点到终点可能改变的最大角度，绕枝干的局部y轴旋转。随机应用于每个段。
	 */
	float GetBendv(int n) const {
		//CHECK(n >= 0 && n < parameter_->levels);

		return GetRandomNumber1() * parameter_->bend_v[n] /
				parameter_->curve_resolution[n];
	}

	/**
	 * 获取-1到1之间的随机数。
	 */
	float GetRandomNumber1() const {
		return uniform_random1_(random_engine_);
	}

	/**
	 * 获取0到1之间的随机数。
	 */
	float GetRandomNumber2() const {
		return uniform_random2_(random_engine_);
	}

	/**
	 * 获取随机数：a + b * uniform(-1, 1)。
	 */
	float GetRandom(float a, float b) const {
		return a + b * GetRandomNumber1();
	}

	/**
	 * 获取下一个深度。
	 *
	 * 对于任何大于此的深度，使用级别3的参数。
	 */
	int NextDepth(int depth) const {
		return std::min(3, depth + 1);
	}

public: // 临时变量
	// 叶子是否已生成。
	bool leaves_generated_ = false;

	// 树的叶子和花朵。
	LocalVector<LeafBlossom> leaves_;

	// 枝干的渲染对象。
	//RenderObject stem_object_;

	// 用于生成树的参数。
	Ref<ProceduralTreeParameter> parameter_;

	// 总分支数。
	int n_branches_ = 0;

	// 总分支段数。
	int n_branch_segments_ = 0;

	// Floyd-Steinberg方法修正非整数值。
	LocalVector<float> split_num_error_;

	// 叶子材质。
	//Material leaf_material_;

	// 叶子颜色。
	Color leaf_color_ = Color(90.0f / 255.0f, 170.0f / 255.0f, 20.0f / 255.0f);

	// 生成-1到1之间的数字。
	mutable std::uniform_real_distribution<float> uniform_random1_;

	// 生成0到1之间的数字。
	mutable std::uniform_real_distribution<float> uniform_random2_;

	// 随机引擎。
	mutable std::mt19937 random_engine_;

public:
	int seed = 234;

	// 用于渲染的枝干LOD。
	int stems_lod_ = 4;
	// 树的当前比例。
	float tree_scale_;

public:
	// 树模型。
	LocalVector<ProceduralTreeStem> tree_;
	// 实例化叶子节点。
	InstanceNode leaves_node_;
	InstanceNode blossom_node_;
};
