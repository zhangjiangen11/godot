//
// Copyright 2022 Yangbin Lin. All Rights Reserved.
//
// Author: yblin@jmu.edu.cn (Yangbin Lin)
//
// This file is part of the Code Library.
//
#pragma once

#include "core/math/color.h"
#include "core/math/plane.h"
#include "core/math/quaternion.h"
#include "core/math/transform_3d.h"
#include "core/math/vector2.h"
#include "core/math/vector3.h"
#include "core/variant/typed_array.h"
#include "scene/main/node.h"
#include <algorithm>
#include <random>

#include "leaf_generator.h"

struct Pipe : public ProceduralTreeRenderData {
	Pipe() {}

	Pipe(const LocalVector<Vector3> &points, float radius, int n_slices = 32) :
			points_(points) {
		radius_.assign(points.size(), radius);
		////CHECK(radius > 0.0f);

		Initialize(n_slices);
	}

	/**
	 * Construct pipe with different radius at each vertex.
	 */
	Pipe(const LocalVector<Vector3> &points, const LocalVector<float> &radius,
			int n_slices = 32) :
			points_(points),
			radius_(radius) {
		////CHECK(points.size() == radius.size());

		Initialize(n_slices);
	}

	/**
	 * Construct a cylinder.
	 */
	Pipe(const Vector3 &p1, const Vector3 &p2, float radius,
			int n_slices = 32) :
			points_({ p1, p2 }) {
		radius_.assign(2, radius);
		////CHECK(radius > 0.0f);

		Initialize(n_slices);
	}

private:
	void Initialize(int n_slices) {
		////CHECK(points_.size() == radius_.size());
		////CHECK(n_slices >= 3);

		if (points_.size() <= 1) {
			return;
		}

		LocalVector<Vector3> ps;
		float angle = 2.0f * float(Math::PI) / n_slices;
		float r = 0.0f;
		for (int i = 0; i < n_slices; ++i, r += angle) {
			ps.emplace_back(std::cos(r), std::sin(r), 0.0f);
		}
		ps.push_back(ps.front());

		const float threshold = std::sqrt(FLT_EPSILON);
		Vector3 v = points_[1] - points_[0];

		Transform3D transform;
		transform.basis.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), Vector3(v.x, v.y, v.z));
		transform.origin = points_[0];
		for (Vector3 &p : ps) {
			p = transform.xform(p);
		}

		// Set vertices and normals.
		for (int j = 0; j < points_.size(); ++j) {
			if (j > 0) {
				const Vector3 &p0 = points_[j - 1];
				const Vector3 &p1 = points_[j];

				Vector3 v1 = p0 - p1;
				float norm = v1.length();
				if (norm <= FLT_EPSILON) {
					continue;
				}
				v1 *= 1.0f / norm;
				Vector3 v = v1;

				if (j + 1 < points_.size()) {
					const Vector3 &p2 = points_[j + 1];
					Vector3 v2 = p2 - p1;
					float norm = v2.length();
					if (norm > FLT_EPSILON) {
						v2 *= 1.0f / norm;

						Vector3 v3 = v1.cross(v2);
						Vector3 v4 = v1 + v2;
						v = v3.cross(v4);
						if (v3.length() < threshold || v4.length() < threshold ||
								v.length() < threshold) {
							v = v1;
						}
					}
				}
				Plane plane(Vector3(v.x, v.y, v.z), Vector3(p1.x, p1.y, p1.z));
				for (int i = 0; i < ps.size(); ++i) {
					//FLine3D line(ps[i], Vector3(v1.x, v1.y, v1.z));
					//geometry::Cross(line, plane, &ps[i]);
					plane.intersects_segment(ps[i], v1, &ps[i]);
				}
			}

			for (int i = 0; i < ps.size(); ++i) {
				vertices.push_back(points_[j] + (ps[i] - points_[j]) * radius_[j]);

				int next = i + 1 == ps.size() ? 1 : i + 1;
				int prev = i == 0 ? ps.size() - 2 : i - 1;
				Vector3 v1 = ps[prev] - ps[i];
				Vector3 v2 = ps[next] - ps[i];
				Vector3 v = -(v1 + v2);
				normals.push_back(v.normalized());
			}

			if (j > 0 && j + 1 < points_.size()) {
				int offset = vertices.size() - ps.size();
				vertices.insert(vertices.begin() + offset,
						vertices.begin() + (offset + ps.size()));
				normals.insert(normals.begin() + offset,
						normals.begin() + (offset + ps.size()));
			}
		}

		// Set texture coordinates.
		for (int j = 0; j < points_.size(); ++j) {
			if (j == 0) {
				for (int i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 0.0f);
				}
			} else if (j + 1 == points_.size()) {
				for (int i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 1.0f);
				}
			} else {
				for (int i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 1.0f);
				}
				for (int i = 0; i < ps.size(); ++i) {
					texture_coords.emplace_back(float(i) / n_slices, 0.0f);
				}
			}

			if (j > 0) {
				int offset = 2 * ps.size() * (j - 1);
				for (int i = 0; i < n_slices; ++i) {
					int next = i + 1;
					indices.push_back(offset + i);
					indices.push_back(offset + next);
					indices.push_back(offset + i + ps.size());

					indices.push_back(offset + i + ps.size());
					indices.push_back(offset + next);
					indices.push_back(offset + next + ps.size());
				}
			}
		}
	}

	// Vertices of the pipe.
	LocalVector<Vector3> points_;

	// Radius of each vertex of the pipe.
	LocalVector<float> radius_;

	// Number of slices of each circle.
	int n_slices = 0;
};

/**
 * Procedural tree generated by parametric method.
 *
 * Reference:
 * [1] Weber, J., & Penn, J. (1995, September). Creation and rendering of
 *     realistic trees. In Proceedings of the 22nd annual conference on Computer
 *     graphics and interactive techniques (pp. 119-128).
 * [2] Hewitt, C. (2017). Procedural generation of tree models for use in
 *     computer graphics [Ph. D. dissertation]: Cambridge. University of
 *     Cambridge.
 */
class ProceduralTree : public Node {
	GDCLASS(ProceduralTree, Node);
	static void _bind_methods() {
	}

public:
	/**
	 * Enum to refer to branching modes.
	 */
	enum BranchMode {
		ALTERNATE_OR_OPPOSITE = 1,
		WHORLED = 2,
		FAN = 3
	};

	/**
	 * Stem of the tree.
	 */
	struct Stem {
		// Depth of this stem.
		int depth = 0;

		// Base radius of the stem.
		float radius = 0.0f;

		// The maximum radius.
		float radius_limit = 0.0f;

		// Length of the stem.
		float length = 0.0f;

		// Maximum length of this stem.
		float max_length = 0.0f;

		// Length of parent stem.
		float parent_length = 0.0f;

		// The position of this stem in the parent trunk.
		float offset = 0.0f;

		// Rotation angle for generating branches and leaves.
		float prev_rotation_angle = 0.0f;

		// Unit grow orientation of this stem.
		Vector3 orientation;

		// Unit face orientation of this stem.
		Vector3 face_orientation;

		// Root position of this stem.
		Vector3 root;

		// Trunk of this stem.
		Pipe trunk;

		// A stem may have multiple sub_stems.
		LocalVector<Stem> sub_stems;

		// Branches of this stem.
		LocalVector<Stem> branches;

		/**
		 * Roll this stem around orientation.
		 */
		void Roll(float degree) {
			Basis rot(orientation, Math::deg_to_rad(degree));
			face_orientation = rot.xform(face_orientation);
		}

		/**
		 * Roll this stem around z axis.
		 */
		void GlobalRoll(float degree) {
			Basis rot(Vector3(0.0f, 0.0f, 1.0f),
					Math::deg_to_rad(degree));
			orientation = rot.xform(orientation);
			face_orientation = rot.xform(face_orientation);
		}

		/**
		 * Pitch this stem around Cross(orientation, face_orientation).
		 */
		void Pitch(float degree) {
			Vector3 v = orientation.cross(face_orientation);
			Basis rot(v, Math::deg_to_rad(degree));
			orientation = rot.xform(orientation);
			face_orientation = rot.xform(face_orientation);
		}
	};

	/**
	 * Leaf/blossom information.
	 */
	struct LeafBlossom {
		Vector3 orientation;
		Vector3 face_orientation;
		Vector3 position;
	};

public:
	explicit ProceduralTree(const std::string &name = "", int seed = 0) :
			uniform_random1_(-1.0f, 1.0f),
			uniform_random2_(0.0f, 1.0f),
			random_engine_(seed) {
		//leaf_material_.ao = 1.0f;
		//leaf_material_.albedo = leaf_color_;
		//leaf_material_.metallic = 0.2f;
		//leaf_material_.roughness = 0.8f;
		//leaves_node_.set_material(&leaf_material_);
		//this->AddNode(&leaves_node_);

		//this->AddRenderObject(&stem_object_);
	}

	/**
	 * Re-generate a tree model according to the given parameters.
	 */
	void Generate(const Ref<ProceduralTreeParameter> &parameter) {
		if (parameter.is_null()) {
			return;
		}
		parameter_ = parameter;

		n_branches_ = 0;
		n_branch_segments_ = 0;
		CreateTree();
		GenerateLeaves();
	}

	/**
	 * Set stems LOD for rendering.
	 */
	void SetStemsLOD(int level) {
		stems_lod_ = level;
	}

	/**
	 * Set leaf color.
	 */
	void set_leaf_color(const Color &color) {
		leaf_color_ = color;
	}

	/**
	 * Set seed for random engine.
	 */
	void set_seed(int seed) {
		random_engine_.seed(seed);
	}

	/**
	 * Return the total number of branches of the tree.
	 */
	int n_branches() const {
		return n_branches_;
	}

	/**
	 * Return the total number of branch segments of the tree.
	 */
	int n_branch_segments() const {
		return n_branch_segments_;
	}

	/**
	 * Return the total number of leaves.
	 */
	int n_leaves() const {
		return leaves_.size();
	}

	/**
	 * return the LOD of stems.
	 */
	int stems_lod() const {
		return stems_lod_;
	}

private:
	/**
	 * Add stem recursively.
	 */
	void AddStems(const Stem &stem) {
		if (stem.depth >= stems_lod_) {
			return;
		}

		//stem_object_.Add(stem.trunk);
		for (const Stem &_stem : stem.sub_stems) {
			AddStems(stem);
		}
		for (const Stem &_stem : stem.branches) {
			AddStems(_stem);
		}
	}

	/**
	 * Create tree.
	 */
	void CreateTree() {
		leaves_generated_ = false;
		tree_.clear();
		leaves_.clear();

		if (parameter_->branches[0] == 0) {
			return;
		}

		std::uniform_real_distribution<float> uniform(0.0f, float(Math::PI) * 2.0f);

		// Calculate Poissonly distributed points for stem start points.
		LocalVector<Vector3> roots;
		if (parameter_->branches[0] == 1) {
			roots.push_back(Vector3(0.0f, 0.0f, 0.0f));
		} else {
			// Calculate approximation spacing radius for dummy stem.
			tree_scale_ = parameter_->scale + parameter_->scale_v;

			Stem temp_stem;
			temp_stem.length = StemLength(temp_stem);
			float radius = 2.5f * temp_stem.length * parameter_->ratio *
					parameter_->radius_modify[0];

			// Generate root points.
			for (int i = 0; i < parameter_->branches[0]; ++i) {
				bool point_ok = false;
				while (!point_ok) {
					// Distance from center proportional for number of splits,
					// tree scale and stem radius.
					float dis = std::sqrt(GetRandomNumber2() *
							parameter_->branches[0] / 2.5f *
							parameter_->scale *
							parameter_->ratio);

					// Angle random in circle.
					float theta = uniform(random_engine_);
					Vector3 pos(dis * std::cos(theta), dis * std::sin(theta),
							0.0f);

					// Test point against those already in array to ensure it
					// will not intersect.
					bool flag = true;
					for (const Vector3 &p : roots) {
						if (p.distance_to(pos) < radius) {
							flag = false;
							break;
						}
					}
					if (flag) {
						point_ok = true;
						roots.push_back(pos);
					}
				}
			}
		}

		for (const Vector3 &root : roots) {
			tree_scale_ = GetRandom(parameter_->scale, parameter_->scale_v);

			Stem stem;
			stem.length = StemLength(stem);
			stem.parent_length = stem.length;
			stem.max_length = GetMaxLength(0);
			stem.radius = stem.length * parameter_->ratio *
					parameter_->radius_modify[0];
			stem.radius_limit = FLT_MAX;
			stem.orientation = Vector3(0.0f, 0.0f, 1.0f);
			stem.root = root;
			if (roots.size() > 1) {
				stem.face_orientation = root.normalized();
				float angle = GetRandomNumber1() * 30.0f;
				stem.Roll(angle);
			} else {
				float angle = uniform(random_engine_);
				stem.face_orientation = Vector3(std::cos(angle),
						std::sin(angle),
						0.0f);
			}

			split_num_error_.assign(parameter_->levels, 0.0f);
			MakeStem(0, 1.0f, 1.0f, &stem);
			tree_.push_back(stem);
		}
	}

	/**
	 * Generate leaves and blossoms.
	 */
	void GenerateLeaves() {
		if (leaves_generated_) {
			return;
		}
		leaves_generated_ = true;

		SetupLeafNode();

		float bend = parameter_->leaf_bend;
		Transform3D leaf_transform;
		Transform3D transform2;
		for (const LeafBlossom &l : leaves_) {
			Transform3D transform;
			transform.origin = Vector3(l.position);
			Basis q;
			q.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), l.orientation);
			Vector3 v = q.xform(Vector3(0.0f, 1.0f, 0.0f));
			Basis q1;
			q1.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), l.face_orientation);
			Transform3D transform1;
			transform1.basis = q1 * q;
			if (bend > 0.0f) {
				float theta_pos = std::atan2(l.position.y, l.position.x);
				float theta_bend = theta_pos - std::atan2(l.face_orientation.y, l.face_orientation.x);
				//FQuaternion q2(Vector3(0.0f, 0.0f, 1.0f), theta_bend * bend);
				Basis q2;
				q2.rotate_to_align(Vector3(0.0f, 0.0f, 1.0f), l.face_orientation);
				transform2.basis = (q2);
				leaf_transform = (transform * transform2 * transform1);
			} else {
				leaf_transform = (transform * transform1);
			}
			if (parameter_->blossom_rate > 0.0f && parameter_->blossom_scale > 0.0f && GetRandomNumber2() < parameter_->blossom_rate) {
				blossom_node_.AddInstance(leaf_transform);
			} else {
				leaves_node_.AddInstance(leaf_transform);
			}
		}
	}

	/**
	 * Set up instanced leaf node.
	 */
	void SetupLeafNode() {
		LeafGenerator leaf_generator;
		ProceduralTreeRenderData leaf_render_data;
		ProceduralTreeRenderData blossom_render_data;
		switch (parameter_->leaf_shape) {
			case 1:
				leaf_generator.OctaveLeaf(&leaf_render_data);
				break;
			case 2:
				leaf_generator.LinearLeaf(&leaf_render_data);
				break;
			case 3:
				leaf_generator.CordateLeaf(&leaf_render_data);
				break;
			case 4:
				leaf_generator.MapleLeaf(&leaf_render_data);
				break;
			case 5:
				leaf_generator.PalmateLeaf(&leaf_render_data);
				break;
			case 6:
				leaf_generator.SpikyOakLeaf(&leaf_render_data);
				break;
			case 7:
				leaf_generator.RoundOakLeaf(&leaf_render_data);
				break;
			case 8:
				leaf_generator.EllipticLeaf(&leaf_render_data);
				break;
			case 9:
				leaf_generator.RectLeaf(&leaf_render_data);
				break;
			case 10:
				leaf_generator.TriangleLeaf(&leaf_render_data);
				break;
		}
		switch (parameter_->blossom_shape) {
			case 1:
				leaf_generator.CherryLeaf(&blossom_render_data);
				break;
			case 2:
				leaf_generator.OrangeLeaf(&blossom_render_data);
				break;
			case 3:
				leaf_generator.MagnoliaLeaf(&blossom_render_data);
				break;
		}

		float scale = parameter_->leaf_scale * tree_scale_ / parameter_->scale;
		float scale_x = parameter_->leaf_scale_x;
		for (Vector3 &p : leaf_render_data.vertices) {
			p *= scale;
			p.x *= scale_x;
		}
		scale = parameter_->blossom_scale * tree_scale_ / parameter_->scale;
		for (Vector3 &p : blossom_render_data.vertices) {
			p *= scale;
		}
		leaves_node_.Reset(leaf_render_data);
		blossom_node_.Reset(blossom_render_data);
	}

	/**
	 * Create a new branch for the current stem segment.
	 */
	void CreateBranch(BranchMode branch_mode,
			const Vector3 &start_point,
			const Vector3 &end_point,
			float offset,
			float stem_offset,
			int branch_index,
			int branches_in_group,
			bool is_leaf,
			Stem *stem) {
		int depth_1 = NextDepth(stem->depth);

		float angle = 0.0f;
		float radius_limit = 0.0f;
		Transform3D transform;
		Vector3 p_euler;
		switch (branch_mode) {
			case FAN:
				if (branches_in_group == 1) {
					angle = 0.0f;
				} else {
					angle = (parameter_->rotation[depth_1] *
									((branch_index / (branches_in_group - 1.0f)) - 0.5f)) +
							GetRandomNumber1() * parameter_->rotation_v[depth_1];
				}
				p_euler.y = (angle);
				radius_limit = 0.0f;
				break;
			case WHORLED:
				angle = stem->prev_rotation_angle +
						(360.0f * branch_index / branches_in_group) +
						GetRandomNumber1() * parameter_->rotation_v[depth_1];
				p_euler.z = (angle);
				radius_limit = CalculateRadius(*stem, stem_offset / stem->length);

				break;
			case ALTERNATE_OR_OPPOSITE:
				angle = GetRotateAngle(depth_1, stem->prev_rotation_angle);
				if (parameter_->rotation[depth_1] >= 0.0f) {
					stem->prev_rotation_angle = angle;
				} else {
					stem->prev_rotation_angle = -stem->prev_rotation_angle;
				}
				p_euler.z = (angle);
				radius_limit = CalculateRadius(*stem, stem_offset / stem->length);
				break;
		}

		// Calculate down angle.
		float d_angle = GetDownAngle(*stem, stem_offset);
		p_euler.x = (d_angle);
		transform.basis = Basis::from_euler(p_euler);

		Stem branch;
		branch.depth = depth_1;
		branch.parent_length = stem->length;
		branch.offset = stem_offset;
		branch.max_length = GetMaxLength(depth_1);
		branch.length = StemLength(branch);
		branch.radius_limit = radius_limit;
		branch.radius = parameter_->radius_modify[depth_1] *
				stem->radius *
				std::pow(branch.length / branch.parent_length,
						parameter_->ratio_power);
		branch.radius = CLAMP(branch.radius, 0.005f, radius_limit);
		branch.orientation = transform.xform(stem->orientation);
		branch.face_orientation = transform.xform(stem->face_orientation);
		branch.root = start_point + (end_point - start_point) * offset +
				radius_limit * branch.orientation;

		if (is_leaf) {
			LeafBlossom leaf;
			leaf.position = branch.root;
			leaf.orientation = branch.orientation;
			leaf.face_orientation = branch.face_orientation;
			if (leaf.face_orientation.z < 0.0f) {
				leaf.face_orientation = -leaf.face_orientation;
			}
			leaf.face_orientation.normalize();
			leaves_.push_back(leaf);
		} else {
			MakeStem(0, 1.0f, 1.0f, &branch);
			stem->branches.push_back(branch);
		}
	}

	/**
	 * Generate stem of the given parameters, as well as all children (branches,
	 * splits and leaves) via recursion.
	 */
	void MakeStem(int start,
			float clone_probability,
			float n_branches_factor,
			Stem *stem) {
		if (start >= parameter_->curve_resolution[stem->depth]) {
			return;
		}

		// If the stem is so thin as to be invisible then don't bother to make
		// it.
		if (stem->radius_limit < 0.0001f) {
			return;
		}

		// Parameters.
		int depth = stem->depth;
		int curve_res = parameter_->curve_resolution[depth];
		float taper = parameter_->taper[depth];
		int base_segment_index =
				static_cast<int>(std::ceil(parameter_->base_size[0] *
						curve_res));
		int base_splits = parameter_->base_splits;
		float seg_splits = parameter_->segment_splits[depth];
		float seg_length = stem->length / curve_res;

		LocalVector<Vector3> vertices;
		LocalVector<float> radius;

		// Start point.
		Vector3 start_point = stem->root;

		vertices.emplace_back(start_point);
		radius.push_back(CalculateRadius(*stem, float(start) / curve_res));

		float branch_count = 0.0f;
		float leaf_count = 0.0f;
		if (depth == parameter_->levels - 1 && depth > 0 &&
				parameter_->n_leaves != 0) {
			// Calculate base leave count.
			leaf_count = CalculateLeafCount(*stem);
			// Correct leaf count for start position along stem.
			leaf_count *= 1.0f - float(start) / curve_res;
		} else {
			// Calculate base branch count.
			branch_count = CalculateBranchCount(*stem);
			// correct branch count for start position along stem.
			branch_count *= 1.0f - float(start) / curve_res;
			// Correct for reduced number on clone branches.
			branch_count *= n_branches_factor;
		}

		// Divide by curve_res to get no per segment.
		float f_leaves_on_segment = leaf_count / curve_res;
		// Divide by curve_res to get no per segment.
		float f_branches_on_segment = branch_count / curve_res;

		// Decide on start rotation for branches/leaves.
		stem->prev_rotation_angle = 0.0f;
		std::uniform_real_distribution<float> uniform(0.0f, 360.0f);
		if (parameter_->rotation[NextDepth(depth)] >= 0.0f) {
			// Start at random rotation.
			stem->prev_rotation_angle = uniform(random_engine_);
		} else {
			// On this case prev_rotation_angle used as multiplier to alternate
			// side of branch.
			stem->prev_rotation_angle = 1.0f;
		}

		// Point resolution for this segment.
		int points_per_segment = 2;
		if (depth == 0 || taper > 1.0f) {
			points_per_segment = std::max(2, 100 / curve_res);
		}

		// Set up Floyd-Steinberg error values.
		float branch_num_error = 0.0f;
		float leaf_num_error = 0.0f;

		for (int i = start; i < curve_res; ++i) {
			bool is_base_split = false;
			// Compute the number of splits at this segment.
			int n_splits = 0;
			if (i != start) {
				if (base_splits > 0 && depth == 0 && i == base_segment_index) {
					n_splits = base_splits;
					is_base_split = true;
				} else if (seg_splits > 0.0f && i + 1 < curve_res &&
						(depth > 0 || i > base_segment_index)) {
					// Otherwise get number of splits from seg_splits and use
					// Floyd-Steinberg to fix non-integer values only clone
					// with probability clone_prob.
					if (GetRandomNumber2() <= clone_probability) {
						n_splits = static_cast<int>(seg_splits +
								split_num_error_[depth]);
						split_num_error_[depth] -= n_splits - seg_splits;

						// Reduce clone/branch propensity.
						clone_probability /= n_splits + 1.0f;
						n_branches_factor /= n_splits + 1.0f;
						n_branches_factor = std::max(0.8f, n_branches_factor);

						branch_count *= n_branches_factor;
						f_branches_on_segment = branch_count / curve_res;
					}
				}
			}

			// Perform spliting if needed.
			float split_corr_angle = 0.0f;
			if (n_splits > 0) {
				float declination = Math::rad_to_deg(stem->orientation.angle_to(
						Vector3(0.0f, 0.0f, 1.0f)));
				float spl_angle = GetSplitAngle(depth, declination);
				float spr_angle = GetSpreadAngle(declination);
				split_corr_angle = spl_angle / (curve_res - i);

				// Make clones.
				for (int j = 0; j < n_splits; ++j) {
					float eff_spr_angle = 0.0f;
					if (is_base_split) {
						eff_spr_angle = GetEffectSpreadAngle(depth, j,
								n_splits);
					} else {
						if (j == 0) {
							eff_spr_angle = spr_angle * 0.5f;
						} else {
							eff_spr_angle = -spr_angle * 0.5f;
						}
					}

					Stem sub_stem = *stem;
					sub_stem.branches.clear();
					sub_stem.sub_stems.clear();
					sub_stem.root = start_point;
					sub_stem.GlobalRoll(eff_spr_angle);
					sub_stem.Pitch(spl_angle * 0.5f);

					MakeStem(i, clone_probability, n_branches_factor,
							&sub_stem);
					stem->sub_stems.push_back(sub_stem);
				}

				stem->Pitch(spl_angle * 0.5f);
				// Apply spread if splitting to 2 and not base split.
				if (!is_base_split && n_splits == 1) {
					stem->GlobalRoll(-spr_angle * 0.5f);
				}
			}

			float radian = CalculateCurveAngle(depth, i);
			stem->Roll(GetBendv(depth));
			stem->Pitch(radian - split_corr_angle);

			// Apply full tropism if not trunk/main branch and horizontal
			// tropism if is.
			if (i > start) {
				ApplyTropism(stem);
			}

			Vector3 v = stem->orientation;
			for (int j = 1; j < points_per_segment; ++j) {
				float offset = float(j) / (points_per_segment - 1);
				float z_norm = (i + offset) / curve_res;
				float r = CalculateRadius(*stem, z_norm);
				radius.push_back(r);
				vertices.emplace_back(start_point + v * offset * seg_length);
			}

			// Add branches/leaves for this segment.
			// If below max level of recursion then draw branches, otherwise
			// draw leaves.
			int branches_on_segment = 0;
			int leaves_on_segment = 0;
			if (branch_count != 0.0f && depth < parameter_->levels - 1) {
				if (branch_count < 0.0f) {
					// Fan branches.
					if (i + 1 == curve_res) {
						branches_on_segment = static_cast<int>(branch_count);
					} else {
						branches_on_segment = 0;
					}
				} else {
					// Get Floyd-Steinberg corrected branch number.
					branches_on_segment =
							static_cast<int>(f_branches_on_segment +
									branch_num_error);
					branch_num_error -= branches_on_segment -
							f_branches_on_segment;
				}

				// Add branches.
				if (branches_on_segment != 0) {
					MakeBranches(i, start_point, start_point + v * seg_length,
							branches_on_segment, false, stem);
				}
			} else if (leaf_count != 0.0f && depth > 0) {
				if (leaf_count < 0.0f) {
					// Fan leaves.
					if (i + 1 == curve_res) {
						leaves_on_segment = static_cast<int>(leaf_count);
					} else {
						leaves_on_segment = 0;
					}
				} else {
					// Get Floyd-Steinberg corrected branch number.
					leaves_on_segment = static_cast<int>(f_leaves_on_segment +
							leaf_num_error);
					leaf_num_error -= leaves_on_segment - f_leaves_on_segment;
				}

				// Add leaves.
				if (leaves_on_segment != 0) {
					MakeBranches(i, start_point, start_point + v * seg_length,
							leaves_on_segment, true, stem);
				}
			}

			start_point += v * seg_length;
			++n_branch_segments_;
		}

		if (depth == 0) {
			stem->trunk = Pipe(vertices, radius, 16);
		} else if (depth == 1) {
			stem->trunk = Pipe(vertices, radius, 8);
		} else {
			stem->trunk = Pipe(vertices, radius, 4);
		}

		++n_branches_;
	}

	/**
	 * Make the required branches for the i-th segment of the stem.
	 */
	void MakeBranches(int segment_index,
			const Vector3 &start_point,
			const Vector3 &end_point,
			int branches_on_segment,
			bool is_leaf,
			Stem *stem) {
		//CHECK(stem);

		float offset = 1.0f;
		float stem_offset = 1.0f;
		if (branches_on_segment < 0) {
			// Fan branches.
			for (int i = 0; i < std::abs(branches_on_segment); ++i) {
				CreateBranch(FAN, start_point, end_point, offset, stem_offset,
						i, std::abs(branches_on_segment), is_leaf, stem);
			}
			return;
		}

		int depth_1 = NextDepth(stem->depth);
		float base_length = stem->length * parameter_->base_size[stem->depth];
		float branch_dist = parameter_->branch_dist[depth_1];
		int curve_res = parameter_->curve_resolution[stem->depth];

		if (branch_dist > 1.0f) {
			// Whorled branches.
			// Calculate number of whorls, will result in a rounded number of
			// branches rather than the exact amount specified by
			// branches_on_segment.
			int num_of_whorls = static_cast<int>(branches_on_segment /
					(branch_dist + 1.0f));
			float branches_per_whorl = branch_dist + 1.0f;
			float branch_whorl_error = 0.0f;

			for (int i = 0; i < num_of_whorls; ++i) {
				// Calculate whorl offset in segment and on stem.
				offset = CLAMP(float(i) / num_of_whorls, 0.0f, 1.0f);
				stem_offset = ((segment_index + offset) / curve_res) *
						stem->length;

				// If not in base area then make the branches.
				if (stem_offset > base_length) {
					// Calculate Floyd-Steinberg corrected num of branches this
					// whorl.
					int branches_this_whorl =
							static_cast<int>(branches_per_whorl +
									branch_whorl_error);
					branch_whorl_error -= branches_this_whorl -
							branches_per_whorl;

					// Set up these branches.
					for (int j = 0; j < branches_this_whorl; ++j) {
						CreateBranch(WHORLED, start_point, end_point, offset,
								stem_offset, j, branches_this_whorl,
								is_leaf, stem);
					}
				}

				// Rotate start angle for next whorl.
				stem->prev_rotation_angle += parameter_->rotation[depth_1];
			}
		} else {
			// Alternate or opposite branches.
			// Ensure even number of branches on segment if near opposite.
			for (int i = 0; i < branches_on_segment; ++i) {
				//  Calculate offset in segment and on stem.
				if (i % 2 == 0) {
					offset = CLAMP(float(i) / branches_on_segment, 0.0f, 1.0f);
				} else {
					offset = CLAMP((i - branch_dist) / branches_on_segment,
							0.0f, 1.0f);
				}

				stem_offset = ((segment_index + offset) / curve_res) *
						stem->length;

				// If not in base area then set up the branch.
				if (stem_offset > base_length) {
					CreateBranch(ALTERNATE_OR_OPPOSITE, start_point,
							end_point, offset, stem_offset, i, 1, is_leaf,
							stem);
				}
			}
		}
	}

	/**
	 * Calculate radius of stem at offset z_1 along it.
	 *
	 * See reference [1] for more details.
	 */
	float CalculateRadius(const Stem &stem, float z_norm) const {
		float n_taper = parameter_->taper[stem.depth];

		float unit_taper = 0.0f;
		if (n_taper < 1.0f) {
			unit_taper = n_taper;
		} else if (n_taper < 2.0f) {
			unit_taper = 2.0f - n_taper;
		}

		// Purely tapered radius.
		float taper = stem.radius * (1.0f - unit_taper * z_norm);

		float radius;
		if (n_taper < 1.0f) {
			radius = taper;
		} else {
			float z2 = (1.0f - z_norm) * stem.length;

			// 'depth' is a scaling factor used for the periodic tapering.
			float depth;
			if (n_taper < 2.0f || z2 < taper) {
				depth = 1.0f;
			} else {
				depth = n_taper - 2.0f;
			}

			float z3;
			if (n_taper < 2.0f) {
				z3 = z2;
			} else {
				z3 = std::abs(z2 - 2.0f * taper * std::round(z2 / (2.0f * taper)));
			}
			if (n_taper < 2.0f && z3 >= taper) {
				radius = taper;
			} else {
				radius = (1.0f - depth) * taper +
						depth * std::sqrt(std::pow(taper, 2.0f) - std::pow((z3 - taper), 2.0f));
			}
		}

		if (stem.depth == 0) {
			float y_val = std::max(0.0f, 1.0f - 8.0f * z_norm);
			float flare = parameter_->flare *
							((std::pow(100.0f, y_val) - 1.0f) / 100.0f) +
					1.0f;
			radius *= flare;
		}
		return radius;
	}

	/**
	 * Calculate the length of the given stem.
	 */
	float StemLength(const Stem &stem) const {
		static float base_length = 0.0f;

		float result = 0.0f;
		if (stem.depth == 0) {
			base_length = stem.length * parameter_->base_size[0];
			result = tree_scale_ * GetMaxLength(0);
		} else if (stem.depth == 1) {
			result = stem.parent_length * stem.max_length *
					ShapeRatio(parameter_->shape,
							(stem.parent_length - stem.offset) /
									(stem.parent_length - base_length));

		} else {
			result = stem.max_length *
					(stem.parent_length - 0.7f * stem.offset);
		}

		return std::max(0.0f, result);
	}

	/**
	 * Compute shape ratio as defined in reference [1].
	 */
	float ShapeRatio(int shape, float ratio) const {
		switch (shape) {
			case 1: // spherical
				return 0.2f + 0.8f * std::sin(float(Math::PI) * ratio);
			case 2: // hemispherical
				return 0.2f + 0.8f * std::sin(float(Math::PI * 2.0) * ratio);
			case 3: // cylindrical
				return 1.0f;
			case 4: // tapered cylindrical
				return 0.5f + 0.5f * ratio;
			case 5: // flame
				return ratio <= 0.7f ? ratio / 0.7f : (1.0f - ratio) / 0.3f;
			case 6: // inverse conical
				return 1.0f - 0.8f * ratio;
			case 7: // tend flame
				return ratio <= 0.7f ? 0.5f + 0.5f * ratio / 0.7f
									 : 0.5f + 0.5f * (1.0f - ratio) / 0.3f;
			case 8: // envelope
				if (ratio < 0.0f || ratio > 1.0f) {
					return 0.0f;
				} else if (ratio < 1.0f - parameter_->prune_width_peak) {
					return std::pow(ratio / (1.0f - parameter_->prune_width_peak),
							parameter_->prune_power_high);
				} else {
					return std::pow((1.0f - ratio) /
									(1.0f - parameter_->prune_width_peak),
							parameter_->prune_power_low);
				}
			default: // conical (0)
				return 0.2f + 0.8f * ratio;
		}
	}

	/**
	 * Apply tropism to stem.
	 */
	void ApplyTropism(Stem *stem) {
		Vector3 v = Vector3(parameter_->tropism[0], parameter_->tropism[1],
				parameter_->tropism[2]);
		if (stem->depth <= 1) {
			v.z = 0.0f;
		}

		if (v.x != 0.0f || v.y != 0.0f || v.z != 0.0f) {
			Vector3 v2 = stem->orientation.cross(v);
			float alpha = v2.length() * 10.0f;

			Basis rot(v2, Math::deg_to_rad(alpha));
			stem->orientation = rot.xform(stem->orientation);
			stem->face_orientation = rot.xform(stem->face_orientation);
		}
	}

	/**
	 * Calculate curve angle for index-th segment on a stem.
	 */
	float CalculateCurveAngle(int depth, int index) const {
		float curve = parameter_->curve[depth];
		float curve_back = parameter_->curve_back[depth];
		int curve_res = parameter_->curve_resolution[depth];
		float curve_v = parameter_->curve_v[depth];

		float curve_angle = 0.0f;
		if (curve_back == 0) {
			curve_angle = curve / curve_res;
		} else if (index < curve_res * 0.5f) {
			curve_angle = curve / (curve_res * 0.5f);
		} else {
			curve_angle = curve_back / (curve_res * 0.5f);
		}

		return GetRandom(curve_angle, curve_v / curve_res);
	}

	/**
	 * Calculate branch count of this stem.
	 */
	float CalculateBranchCount(const Stem &stem) const {
		int depth_1 = std::min(stem.depth + 1, 3);
		float result = 0.0f;

		if (stem.depth == 0) {
			result = parameter_->branches[depth_1] *
					(GetRandomNumber2() * 0.2f + 0.9f);
		} else if (parameter_->branches[depth_1] < 0) {
			result = static_cast<float>(parameter_->branches[depth_1]);
		} else if (stem.depth == 1) {
			result = parameter_->branches[depth_1] *
					(0.2f + 0.8f * (stem.length / stem.parent_length) / stem.max_length);
		} else {
			result = parameter_->branches[depth_1] *
					(1.0f - 0.5f * stem.offset / stem.parent_length);
		}

		return result / (1.0f - parameter_->base_size[stem.depth]);
	}

	/**
	 * Calculate leaf count of this stem.
	 */
	float CalculateLeafCount(const Stem &stem) const {
		if (parameter_->n_leaves >= 0) {
			// Scale number of leaves to match global scale and taper.
			float n = parameter_->n_leaves * tree_scale_ / parameter_->scale;
			return n * (stem.length / (stem.max_length * stem.length));
		}

		return static_cast<float>(parameter_->n_leaves);
	}

	/**
	 * Get rotate angle, limit to 0-360.
	 */
	float GetRotateAngle(int n, float prev_angle) const {
		float r_angle;
		if (parameter_->rotation[n] >= 0.0f) {
			r_angle = prev_angle + GetRandom(parameter_->rotation[n], parameter_->rotation_v[n]);
		} else {
			r_angle = prev_angle * (180.0f + GetRandom(parameter_->rotation[n], parameter_->rotation_v[n]));
		}
		r_angle = std::fmod(r_angle, 360.0f);
		if (r_angle < 0.0f) {
			r_angle += 360.0f;
		}
		return r_angle;
	}

	/**
	 * Get down angle for branches or leaves.
	 */
	float GetDownAngle(const Stem &stem, float stem_offset) const {
		int depth_1 = NextDepth(stem.depth);
		float d_angle = 0.0f;
		if (parameter_->down_angle_v[depth_1] >= 0.0f) {
			d_angle = GetRandom(parameter_->down_angle[depth_1],
					parameter_->down_angle_v[depth_1]);
		} else {
			float base_size = parameter_->base_size[stem.depth];
			float ratio = ShapeRatio(0, (stem.length - stem_offset) / (stem.length * (1.0f - base_size)));
			d_angle = parameter_->down_angle[depth_1] +
					parameter_->down_angle_v[depth_1] * (1.0f - 2.0f * ratio);
		}

		// Introduce some variance to improve visual result.
		return GetRandom(d_angle, std::abs(d_angle * 0.1f));
	}

	/**
	 * Get the maximum length of the n-th level branch.
	 */
	float GetMaxLength(int n) const {
		return GetRandom(parameter_->length[n], parameter_->length_v[n]);
	}

	/**
	 * Get the split angle.
	 */
	float GetSplitAngle(int n, float declination) const {
		//CHECK(n >= 0 && n < parameter_->levels);

		float angle = GetRandom(std::abs(parameter_->split_angle[n]),
				parameter_->split_angle_v[n]);
		return std::max(0.0f, angle - declination);
	}

	/**
	 * Get spread angle of the stem after splitting.
	 */
	float GetSpreadAngle(float declination) const {
		return -(20.0f + 0.75f * (30.0f + std::abs(declination - 90.0f)) * std::pow(GetRandomNumber2(), 2.0f));
	}

	/**
	 * Get spread angle of the i-th clones.
	 */
	float GetEffectSpreadAngle(int depth, int i, int n_splits) const {
		//CHECK(i >= 0 && i < n_splits);
		//CHECK(depth >= 0 && depth < parameter_->levels);

		return (i + 1) * 360.0f / (n_splits + 1) + GetRandomNumber1() * parameter_->split_angle_v[depth];
	}

	/**
	 * Get the maximum angle by which the direction of the stem may change from
	 * start to end, rotating about the stem's local y-axis. Applied randomly at
	 * each segment.
	 */
	float GetBendv(int n) const {
		//CHECK(n >= 0 && n < parameter_->levels);

		return GetRandomNumber1() * parameter_->bend_v[n] /
				parameter_->curve_resolution[n];
	}

	/**
	 * Get random number from -1 to 1.
	 */
	float GetRandomNumber1() const {
		return uniform_random1_(random_engine_);
	}

	/**
	 * Get random number from 0 to 1.
	 */
	float GetRandomNumber2() const {
		return uniform_random2_(random_engine_);
	}

	/**
	 * Get random number: a + b * uniform(-1, 1).
	 */
	float GetRandom(float a, float b) const {
		return a + b * GetRandomNumber1();
	}

	/**
	 * Get next depth.
	 *
	 * Use level 3 parameters for any depth greater than this.
	 */
	int NextDepth(int depth) const {
		return std::min(3, depth + 1);
	}

	// Tree model.
	LocalVector<Stem> tree_;

	// Leaves generated.
	bool leaves_generated_ = false;

	// Tree leaves and blossoms.
	LocalVector<LeafBlossom> leaves_;

	// Render object for stems.
	//RenderObject stem_object_;

	// ProceduralTreeParameter for generating tree.
	Ref<ProceduralTreeParameter> parameter_;

	// Current scale of the tree.
	float tree_scale_;

	// Total branches.
	int n_branches_ = 0;

	// Total branch segments.
	int n_branch_segments_ = 0;

	// Floyd-Steinberg method to fix non-integer values.
	LocalVector<float> split_num_error_;

	// Stems LOD for rendering.
	int stems_lod_ = 4;

	// Instance leaves node.
	InstanceNode leaves_node_;
	InstanceNode blossom_node_;

	// Material for leaves.
	//Material leaf_material_;

	// Color of leaves.
	Color leaf_color_ = Color(90.0f / 255.0f, 170.0f / 255.0f, 20.0f / 255.0f);

	// Generate numbers from -1 to 1.
	mutable std::uniform_real_distribution<float> uniform_random1_;

	// Generate numbers from 0 to 1.
	mutable std::uniform_real_distribution<float> uniform_random2_;

	// Random engine.
	mutable std::mt19937 random_engine_;
};
